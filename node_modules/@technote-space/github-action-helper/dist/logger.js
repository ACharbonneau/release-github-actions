"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const signale_1 = require("signale");
const types_1 = __importDefault(require("signale/types"));
/**
 * Logger
 */
class Logger {
    /**
     * @param {function|undefined} replacer replacer
     * @param {object|undefined} signaleSettings signale settings
     */
    constructor(replacer, signaleSettings) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.output = (type, message, ...args) => {
            this.signale[type](this.replacer(message), ...args.map(arg => 'string' === typeof arg ? this.replacer(arg) : arg));
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.info = (message, ...args) => this.output('info', message, ...args);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.displayCommand = (message, ...args) => this.output('log', `[command]${message}`, ...args);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.displayStdout = (message) => message.replace(/\r?\n$/, '').split(/\r?\n/).forEach(line => this.output('log', `  >> ${line}`));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.displayStderr = (message) => message.replace(/\r?\n$/, '').split(/\r?\n/).forEach(line => this.output('warn', `  >> ${line}`));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.startProcess = (message, ...args) => {
            this.endProcess();
            this.output('log', `##[group]${message}`, ...args);
            Logger.isRequiredEndGroup = true;
        };
        this.endProcess = () => {
            if (Logger.isRequiredEndGroup) {
                this.output('log', '##[endgroup]');
                Logger.isRequiredEndGroup = false;
            }
        };
        this.signale = new signale_1.Signale(Object.assign({}, {
            types: {
                info: {
                    color: 'cyan',
                },
            },
        }, signaleSettings));
        this.replacer = replacer ? replacer : (text) => text;
        Object.keys(types_1.default).forEach(type => {
            if (!this[type]) {
                this[type] = this.signale[type];
            }
        });
    }
}
exports.Logger = Logger;
Logger.isRequiredEndGroup = false;
Logger.resetForTesting = () => {
    Logger.isRequiredEndGroup = false;
};
//# sourceMappingURL=logger.js.map